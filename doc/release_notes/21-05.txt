

              ===============================================
              Release notes for the Genode OS Framework 21.05
              ===============================================

                               Genode Labs



; intro -> @nfeske


Webcam support
##############

https://libusb.info
https://ken.tossell.net/libuvc/doc
https://chromium.googlesource.com/libyuv/libyuv

During 2020 the amount of home office and remote work took an unexpcted turn.
Video conferences and video chats have become the norm on which people and
companies rely upon. Even though, not to be found on our
[https://genode.org/about/road-map - road map] for 2021 this development let the
Genode team explore the field of webcam and video chat support on Genode.

Webcams are generally connected via USB to a host device and implement the USB
video device class
([https://www.usb.org/sites/default/files/USB_Video_Class_1_5.zip - UVC]).
Therefore, it becomes possible to drive many different webcam devices using the
same USB interface. To support this protocol we enabled
[https://ken.tossell.net/libuvc/doc - libuvc] which offers fine grained control
over UVC exporting USB devices. In order to enable _libuvc_ on Genode we simply
integrated the library into Genode's port system with no further changes
required. _libuvc_ depends on
[https://libusb.info - libusb] as a back end to access the actual webcam
device. While there exists a port of _libusb_ for Genode - that connects through
Genode's USB session interface to the USB host controller - the port still lacked
support for isochronous USB transfers as required by UVC devices. Isochronous
transfers represent a continuous stream of data (either input or output) with a
constant rate without delivery guarantees. We extended _libusb_ to handle
isochronous transfers which were already supported by Genode's USB session and
because these kind of transfers can cause high load within the USB host driver
optimized isochronous transfer support at the host driver level (Section [USB]).

At the front end side we wrote a small _usb_webcam_ component that takes
advantage of _libuvc_ in order to enable, disable, and configure the camera. The
component provides a GUI session, and thus, can be connected directly, for
example, to the Nitpicker component for rendering webcam images natively on
screen. While Genode's pixel format is 24 Bit with added alpha channel, webcams
stream data in the YUV2, MJPEG, or H.264 formats. To handle the conversion of
these formats to Genode's pixel format we take advantage of
https://chromium.googlesource.com/libyuv/libyuv - libyuv] and currently support
the YUV2 as well as the MJPEG pixel format for webcams.

Additionally we wanted to be able to transfer the webcam data directly into our
VirtualBox port, thus enabling, sophisticated video conference systems like
Jitsi or Skype.

Our USB support for our VirtualBox port is based on the ported Qemu USB XHCI
model. Since no USB webcam model is available for Qemu, we were required
to develop a model from scratch. The new USB webcam model is attached to the
QEMU USB XHCI model and operates as a bulk entrypoint. In contrast to an
isochonous entrypoint, the model causes less CPU load and fewer virtual
interrupts. The announced supported formats to the guest are YUV2 and BGR3.
By enabling the USB webcam model in the Genode VirtualBox configuration,
an _Capture_ session is esablished and will catpure pictures in the
rate of the configured _fps_. The following attributes are the default ones:

!<config ...>
!	...
!	<webcam width="640" height="480" fps="15" vertical_flip="false" screen_size="false" report="false"/>
!	...
!</config>

If the _screen_size_ attribute is set to _true_, the model will determine the
resolution of the established capture session, otherwise the specified
_width_ and _height_ values are used. The _vertical_flip_ attribute is useful
for the BGR3 format, which is interpreted by Linux guests flipped vertically and
can be re-flipped by setting the attribute to _true_.

If the _report_ attribute is set to _true_, a Genode report will be generated
whenever the guest changes the state of the capturing, either switching
capturing on/off or changing the format.

! <capture enabled="true/false" format="YUV2/BGR3"/>


Performance optimizations
#########################

One of the overarching topics of this year's
[https://genode.org/about/road-map - roadmap] is optimization.
As part of working on the Sculpt OS
[https://genode.org/news/sculpt-os-21.03-boots-now-in-2.5-seconds - version 21.03],
we identified several optimization vectors with the potential for user-visible
improvements. In particular, while interacting with the system, a few effects
made us curios.

Operations that involved changes of the runtime subsystem, e.g., adding or
reconfiguring a component, seemed to interfere with multi-media workloads.
When running a graphical animation, we could see it stutter in such
situations.

The boot time of Sculpt OS has always been relatively quick compared to
commodity operating systems. E.g., on a 5-years old laptop like a Lenovo
x260, it used to boot in about 5 seconds to the graphical user interface.
However, with the anticipation of Sculpt OS on lower-end platforms like the
Pinephone and with the vision of instant-on systems, we wondered about the
potential for improvement.

While gathering a CPU-load profile of the boot process using the top tool,
we learned that the boot time was bounded not by I/O but by the CPU load
(the kernel's idle thread did not appear in the profile). Interestingly,
a significant porting of the cycles were consumed by various instances of
the init component, which prompted us to focus our attention to the
implementation of init.


Clock-cycle measurements
------------------------

The next natural step was the benchmarking of various code paths of init
using precise a cycle-accurate time-stamp counter (TSC).
Even though Genode has a 'Trace::timestamp' utility readily available, it remains
barely used for manual instrumentation because such instrumentations require
too much labor: allocation of state variables for gathering the statistics,
computing time differences, traffic-shaping of the debug noise (needed
whenever investigating highly frequently called code). These tasks should
better be covered by a utility so that friction-less performance analysis can
become a regular part of our development work. The current release
introduces a simple utility called 'GENODE_LOG_TSC' to the API. This
utility is covered by a dedicated article.

:Performance analysis made easy:

  [https://genodians.org/nfeske/2021-04-07-performance]

Thanks to this utility, we were able identify three concrete opportunities
for optimization in a course of one evening. First, the dynamic
reconfiguration of init apparently did not scale well with a growing number of
components. The code for analysing differences of configuration versions
relied on doubly nested loops in order to stay as simple as possible. With the typical number
of 30 or more components/subsystems hosted in Sculpt's runtime, we passed the
tipping point where quadratic time complexity is justifiable.
Second, during a
configuration update, the XML data is evaluated in multiple passes, which puts
pressure on Genode's XML parser, which could in principle be relieved. Third,
the process of taking session-routing decisions involved XML parsing. In
scenarios as sophisticated as Sculpt, the routing rules can become quite
elaborate. Since the rules are consulted for each session route, the costs for
the rule evaluations add up.


Init optimizations
------------------

These realizations motivated us to replace the hand-crafted config processing
by the use of Genode's generic 'List_model' utility. This way, the parsing
follows a common formalism that makes the code easier to maintain and to
understand while reducing the XML parsing to a single pass. The increased
formality cleared the way for further optimizations.
In particular, init became able to skip
the re-evaluation of the session routing whenever no service is affected
by the config change. This is actually the common case in Sculpt.

To alleviate the costs for evaluation session routes, we introduced
an internal data model for the routing rules that is optimized for the
matching of routes. With this model, the detection of a definite mismatch
(the common case) comes down to a comparison of a single numeric value.

Combined, those optimizations show a great effect. In a typical Sculpt
system, the time of a dynamic reconfiguration got reduced by factor 10
to the order of 10 to 20 ms. Hence, the visual stuttering we observed during
structural changes of the runtime are completely eliminated.

Besides the major optimization of init, we were able to shave off a few
milliseconds here and there.
For example, by deferring the initialization of the RTC driver to its
first use, we avoid an (potentially expensive) active polling loop during
the highly contended boot phase.
Another obvious heuristic improvement is the skipping the GUI handling
until the framebuffer driver is up because all the nice pixels would not
be visible anyway.

Combined, these optimizations were able to reduce the boot time of Sculpt from
the starting time of the kernel up to the graphical user interface down to
only 2.3 seconds. The improved performance of init is impactful beyond Sculpt
OS because it is a central component of all Genode systems large and small.


Updated and new documentation
#############################

Genode Platforms
----------------

We are proud to introduce the first version of a new "Genode Platforms"
document, which complements the existing Genode Foundations book with
low-level hardware-related topics. It is primarily intended for integrators
and developers of device drivers.

: <div class="visualClear"><!-- --></div>
: <p>
:  <div style="clear: both; float: left; margin-right:20px;">
:   <a class="internal-link" href="https://genode.org">
:    <img class="image-inline" src="https://genode.org/documentation/genode-platforms-title.png">
:   </a>
:  </div>
: </p>

In this first edition, the document features a practical guide for the steps
needed to bring Genode to a new ARM SoC. The content is based on the ongoing
Pine Fun article series at [https://genodians.org - Genodians.org].
We plan to continuously extend it with further practical topics as we go.

:Initial revision of the Genode Platforms document:

  [https://genode.org/documentation/genode-platforms-21-05.pdf]


Genode Foundations
------------------

The "Genode Foundations" book received its annual update. It is available at
the [https://genode.org] website as a PDF document and an online version.
The most noteworthy additions and changes are:

: <div class="visualClear"><!-- --></div>
: <p>
:  <div style="clear: both; float: left; margin-right:20px;">
:   <a class="internal-link" href="https://genode.org">
:    <img class="image-inline" src="https://genode.org/documentation/genode-foundations-title.png">
:   </a>
:  </div>
: </p>

* Adaptation to the re-stacked GUI stack of
  [https://genode.org/documentation/release-notes/20.08#The_GUI_stack__restacked version 20.08]
* Coverage of the new uplink, capture, and event session interfaces
* Updated API documentation

: <div class="visualClear"><!-- --></div>

To examine the changes in detail, please refer to the book's
[https://github.com/nfeske/genode-manual/commits/master - revision history].


Base framework and OS-level infrastructure
##########################################


API refinements
===============

VFS-access utilities
--------------------

Low-complexity native Genode components do not depend on a C runtime. To allow
such components to enjoy the power and flexibility of the our VFS
infrastructure, the framework provides an evolving front-end API
[https://github.com/genodelabs/genode/blob/master/repos/os/include/os/vfs.h - os/vfs.h]
introduced in version
[https://genode.org/documentation/release-notes/19.11#Virtual_file-system_infrastructure - 19.11].

The API is tailored and refined according to the relatively simple use cases
of low-complexity Genode components. The current release introduces a new
utility for the creation of new files, appropriately named 'New_file'. The
change is accompanied with a new 'Directory::create_sub_directory' method for
the easy creation of directory hierarchies.


Safeguarded arrays
------------------

To handle arrays in a more safe, and C++ like fashion a new helper class is
available under 'repos/base/include/util/array.h'. Currently, elements can be
added dynamically or at construction time, but never removed.


Cosmetic changes
----------------

The new version refines the 'Range_allocator::alloc_aligned' interface to make
it more safe. The former 'from' and 'to' arguments are replaced by a single
'range' argument. The distinction of the use cases of regular allocations vs.
address-constrained allocations is now covered by a dedicated overload instead
of relying on a default argument. The 'align' argument has been changed from
'int' to 'unsigned' to be better compatible with 'addr_t' and 'size_t'.

The 'Cache_attribute' type has been renamed to 'Cache'.


Input-event handling
====================

A central component for Genode's input-event handling functionality is the event
filter. It merges input events from multiple event sources and passes them to
the event sink (typically the GUI server). In between, it performs low-level
key remapping and applies character mapping rules. Character mapping rules are
essential for supporting different keyboard layouts (including dead-key
sequences). Low-level key remapping is, for instance, used for changing the
emitted key codes of the numpad keys according to the numlock state. The
different filter functionalities can be arbitrarily assembled into a filter
chain and provided as a dynamic config ROM to the event filter component. The
event sink then receives and processes the filtered events.

However, some input devices emit unusual and/or extra key codes in certain
situations, which impedes the event sink's ability to detect key combos
correctly. We therefore added the functionality to completely mute certain key
codes. In order to ignore all unknown key codes for instance, we can now add an
'<ignore-key>' node to the config of the event filter.

! <remap>
!   <ignore-key name="KEY_UNKNOWN"/>
!   [...]
! </remap>

Note, that '<ignore-key>' is part of the '<remap>' filter. The name attribute
refers to the low-level key name before any remapping rule has been applied.

As a second addition, we implemented a '<log>' filter that allows low-level
debugging of the event filter component and its configuration. The '<log>'
filter can appear at every stage in the filter chain. For instance, we can log
the input events before and after the remap filter as follows.

! <log prefix="REMAPPED ">
!   <remap>
!     <log prefix="RAW ">
!       [...]
!     </log>
!   </remap>
! </log>

The optional 'prefix' attribute thereby helps distinguishing the log output from
different stages.


File-system helpers
===================

The fs_query component is a simple helper to query information from a file
system. E.g., it is used by the file browser of Sculpt OS to obtain the
directory structure. The component received two welcome improvements. First,
directory content is now reported in alphabetic order. Thereby, all consumers
of the reports become able to rely on a deterministic output. For example, the
file browser of Sculpt OS, the launcher menu items, and the depot-selection
items will appear in a predictable way. Second, the size of files can be
queried now. By adding an attribute 'size="yes"' to a query, fs_query is
instructed to report the size of each queried file as attribute 'size' of the
corresponding 'file' node.

Whereas fs_query inspects a file system without changing it, its sister
component fs_tool is able to perform file-system modifications. The new
version adds a '<new-file path="...">' operation, which writes the content of
the XML node into the file specified as 'path' attribute. The directory
structure leading to the file is implicitly created if needed. Should a file
with the specified name already exist, the original file gets overwritten.


Applications
############

File vault based on the CBE block encrypter
===========================================

Throughout many releases now
([https://genode.org/documentation/release-notes/19.11#Preliminary_block-device_encrypter - 19.11],
[https://genode.org/documentation/release-notes/20.05#Feature-completeness_of_the_consistent_block_encrypter - 20.05],
[https://genode.org/documentation/release-notes/20.08#Consistent_Block_Encrypter - 20.08],
[https://genode.org/documentation/release-notes/20.11#Consistent_Block_Encrypter__CBE_ - 20.11]),
we persistently worked at a native solution for modern block encryption - the
SPARK-based CBE-library - and its integration into Genode's VFS. This work was
already in a shape that allowed for real-world scenarios like
[https://genodians.org/m-stein/2020-06-12-cbe-linux-vm - hosting a Linux VM ontop of the encrypted block device].
However, it still lacked a notable amount of operating hours because its
integration into an end-user system like Sculpt was mainly low-level magic -
complex and error-prone.

This had to change, because we want to encourage as many people as possible to
expose the codebase around the CBE to their workflow and let it mature.
Therefore, we came up with the new file vault package. It is a graphical front
end that aims for making it most intuitive and secure to create and maintain
virtual file systems that are encrypted and managed through the CBE. We
introduced the package recently in detail in
[https://genodians.org/m-stein/2021-05-17-introducing-the-file-vault - this Genodians article].

[image file_vault_setup]

The file vault only requires two file system sessions from you (the Trust
Anchor is stored separately). With that, it will automatically create and
connect a Trust Anchor, set up a CBE image, prepare an ext2 FS ontop of the CBE
image and provide it through a file system service - ready to be used like a
simple directory. The directory can be locked by closing the file vault and
unlocked by starting the file vault on the same Trust Anchor and entering the
correct user passphrase. All controls regarding the CBE behind this directory,
like re-sizing and re-keying, are presented though a simple and guiding UI that
also provides you with the most relevant status information on your vault.

The file vault package is accompanied by some notable improvements regarding
the CBE key management. While in the last release, this aspect was still only a
prototype with almost no protective value, the current implementation sets on
well-known algorithms to generate and encrypt the keys used in the CBE
respectively the file vault. This is also explained in detail in the above
mentioned article.

Of course, as the text already indicated, the purpose of the current version of
the file vault is to lift native block encryption in Genode out of the
comfort-zone of a mere proof-of-concept. Consequently, you should still use the
application with great care and for non-critical data only! Furthermore, we
would be more than happy to receive feedback on your experience with the file
vault!


VirtualBox
==========

Since the last release, we continued the enablement of VirtualBox 6 on Genode
and put efforts into stabilizing the port. Therefore, we updated to version
6.1.18 and reorganized the internal structure for a more comprehensible
execution model with less threads. Further, we improved synchronization in
multi-processor use cases and added a Sculpt runtime package for vbox6.

Finally as a little treat, our ports of VirtualBox now support to pass extra
buttons of five-button mice to the guest.


Device drivers
##############

Platform driver on ARM
======================

The current release largely streamlines Genode's API for interacting with the
platform driver on ARM platforms. It eases the access to memory-mapped I/O
registers and interrupts by introducing the notions of

:'Platform::Device': one device obtained from a platform session

:'Platform::Device::Mmio': locally-mapped MMIO registers of a device

:'Platform::Device::Irq': interface for receiving device interrupts

The API is covered in detail the following article.

:One Platform driver to rule them all:

  [https://genodians.org/nfeske/2021-04-29-platform-driver]

It goes without saying that this change touches most drivers.
Closely related, we also revised the concept of the XML based device-info
mechanism provided by the platform driver to accommodate both complex drivers
operating on multiple device simultaneously such as driver stacks ported from
Linux as well as low-complexity drivers for simple devices. In the new
version, the device XML information dataspace is only provided if the client's
session policy states 'info="yes"'. The format of the XML information got
refined to include the physical resource names (I/O memory and IRQ addresses)
instead of virtual IDs and page offsets and by using a 'type' attribute
instead of a '<compatible>' node to uniquely identify devices.


Changes specific to i.MX8
-------------------------

The platform driver incarnation specific to i.MX8 got improved slightly.
It can handle the configuration of reset-pins now. Analoque to the already
existent power domains, one can assign reset domains per device. Whenever a
device with a reset domain gets acquired, its reset-pins are deasserted. When the
device gets released again, its reset-pins are asserted to put it into reset
state. A sample configuration looks like the following:

! <device name="mipi_dsi>
!   <reset-domain name="mipi_dsi_pclk"/>
!   ...
! </device>

Technically, those reset domains map to pin settings of the System Reset
Controller (SRC) that is part of the i.MX8 SoC. The SRC is under control of the
platform driver now. Currently, only the pins for the MIPI DSI Phy get exported.
They are used by the graphical subsytem to handle panels connected via MIPI DSI.


I2C driver for i.MX8
====================

Thanks to Jean-Adrien Domage from [https://www.gapfruit.com - gapfruit] an
API for I2C bus transactions, and a new I2C bus driver for the i.MX8 SoC entered
our framework.

Coincidentally, the need to use the new I2C API more intensively arised
soon after his initial contribution. As a consequence the API got extended a
bit. The result is a nice joint venture, and looks like the following:

! void transmit(Transaction & t);

Hereby a 'Transaction' is a simple array of 'Message' objects, and a 'Message'
is an array of bytes that are either read or written. For very simple use-cases,
e.g., a client that polls single bytes from a temperature sensor, some convenience
utilities are incorporated into the 'I2C::Connection'.


USB
===

The USB-driver system has received quite a few refinements, performance
improvements, and robustness handling efforts during the current release cycle.
The HID subsystem is now capable of handling devices where the HID USB interface
is at an arbitrary location within the device descriptors - as opposed to the
assumption that the HID interface is always at the first position in interface
list of the device. Also the HID drivers now handles session destruction more
gracefully and supports unlimited plug and unplug events of an associated HID
device.

For the USB host driver various fixes of newer Linux kernel versions have been
back ported which concern the handling of DMA memory, error code and timeout
handling have been improved in order to support more corner cases, and the USB
session handles outstanding USB requests (synchronous and asynchronous) on
sudden session disconnects gracefully.

The CPU usage of the host driver for isochronous transfers has been reduced
significantly for Intel XHCI controllers, by adding a fix that does not trigger
an interrupt for every completed isochronous packet, but for every eighth,
bringing the worst case scenario down to 1000 IRQ/s from a possible 8000 IRQ/s
before.


NIC drivers
===========

Drivers for iPXE-supported ethernet devices, WiFi adapters, and Linux
TAP devices now support to report the MAC address of detected
adapters. The feature can be enabled by a '<report>' node in the driver
configuration like follows and requests a Report session with the
label _devices_.

! <config>
!   <report mac_address="true"/>
! </config>

The resulting report is depicted below.

! <devices>
!   <nic mac_address="02:00:00:00:00:01"/>
! </devices>


Platforms
#########

Genode/Linux on 64-bit ARM
==========================

The release introduces the support for running the Linux version of Genode on
64-bit ARM platforms. As a part of this line of work, Genode's system call
bindings for Linux underwent a modernization to harmonize the system calls
across the supported CPU architectures. Furthermore, we took the opportunity
to simplify the use of the clone system call by eliminating the need for a TLS
pointer.

Expecting that the 64-bit Genode/Linux version will remain a niche
use case of Genode in the foreseeable future, we do not provide a pre-built
tool chain. Hence, as a preparatory step of using this version of Genode, the
tool chain must by built manually via Genode's _tool/tool_chain_ script.

As a known limitation, Genode's 'Trace::timestamp' function is not available
on this version of Genode because Linux prevents the user land from accessing
the cycle counter (pmccntr_el0). So the accuracy of timing is somewhat impeded
to the order of milliseconds. Also, the jitterentopy random-number generator
cannot be used.

Those limitations notwithstanding, one can successfully execute scenarios as
complex as _leitzentrale.run_. When using AARCH64 Linux as host, run scripts
can be executed with the same convenience as on Linux on a PC.

! $ make run/<script> KERNEL=linux BOARD=linux


Pine-A64-LTS single board computer
==================================

The current release continues
[https://genode.org/documentation/release-notes/21.02#Pine-A64-LTS_single_board_computer - our story]
of porting Genode to the
[https://pine64.com/product-category/pine-a64-ltslong-term-supply/ - Pine-A64-LTS]
board. We take the chance to document the process in great detail as we go.

# [https://genodians.org/nfeske/2021-03-05-pine-fun-testing - Kernel packaging and testing]
# [https://genodians.org/nfeske/2021-03-17-pine-fun-device-access - Device access from the user level]
# [https://genodians.org/nfeske/2021-04-29-platform-driver - One Platform driver to rule them all]
# [https://genodians.org/nfeske/2021-05-12-pine-fun-linux - Taking Linux out for a Walk]
# [https://genodians.org/nfeske/2021-05-19-pine-dts-pruning - Pruning device trees]

The accumulated material form the basis for the evolving Genode Platforms
document introduced in Section [Updated and new documentation].

The code of this line of work is available at a dedicated repository:

:Genode board support for Allwinner SoCs:

  [https://github.com/nfeske/genode-allwinner]


RISC-V
======

The support for the RISC-V architecture has further been developed into the
direction of a fully supported Genode platform. With this release we wanted to
enable basic device driver support which requires a working interrupt
controller. Since the "platform-level interrupt controller" (PLIC) is now
present on most hardware as well and as on the Qemu emulator, we have added support
for the PLIC within our base-hw kernel.

With the interrupt controller in place we implemented a driver for the
[https://opencores.org - OpenCores] Ethernet device as present on the
[https://hensoldt-cyber.com/mig-v - MiG-V] board. The driver component runs on
Qemu (with OpenCores enabled) as well as on the MiG-V board itself. Our RISC-V
board specific line of work can now be found within a separate
[https://github.com/ssumpf/genode-riscv - repository].

With driver support in place the final step for full RISC-V support in Genode is
to our C library for this architecture.


Build system and tools
######################

Tool-chain update to GCC 10.03 and binutils 2.36
================================================

; @cproc

; What's new?
; Anecdotes
; Typical stumbling blocks?
; Current limitations? RISC-V?

commit 7fd598f0c1c82837d5ee02db3fe4a8b00abd4385
Author: Christian Prochaska <christian.prochaska@genode-labs.com>
Date:   Tue Apr 20 11:20:55 2021 +0200

    tool_chain: build 'gprbuild' from source
    
    The 'gprbuild' version which is provided by Ubuntu 18.04 has a bug
    which prevents it from building 'ali2dep' with gcc/gnat 10. With
    this commit, a newer 'gprbuild' version is built from source.
    
    Issue #4094

commit 6a11b78cdf746804bd8a150942bf87c400958f94
Author: Christian Prochaska <christian.prochaska@genode-labs.com>
Date:   Wed Mar 24 22:03:18 2021 +0100

    tool_chain: use gcc-provided dependency libraries
    
    Download gmp, mpc and mpfr with the download script provided by the
    gcc source tree and let the gcc build system handle the build of these
    libraries with the correct compile options. This fixes build issues on
    armhf Linux and removes the need to maintain mpc and mpfr ports in
    the Genode tree.
    
    Issue #4094

commit fc902d9e660aad3a2aadf256b1fa25ad898acb49
Author: Christian Prochaska <christian.prochaska@genode-labs.com>
Date:   Fri Mar 26 11:54:08 2021 +0100

    tool_chain: update binutils to version 2.36.1
    
    Issue #4094

commit 6639261126702aa1b91174fd95e48e4f4359a892
Author: Sebastian Sumpf <sebastian.sumpf@genode-labs.com>
Date:   Fri May 7 11:40:01 2021 +0200

    binutils: augment equally-named sections again
    
    Revert GNU ld to the old behavior where sections with the same name in multiple
    ld scripts are merged. Binutils 2.36.1 creates two sections with the same name.
    
    Fixes #4126

commit d0054ca378bad255cadeaa41f2dc21b2a139508a
Author: Christian Prochaska <christian.prochaska@genode-labs.com>
Date:   Mon Mar 29 19:36:20 2021 +0200

    tool_chain: update gcc to version 10.3.0
    
    Issue #4094

commit 7f452fd2be03a1ef4b2144c07e4a5ea2fffeae92
Author: Christian Prochaska <christian.prochaska@genode-labs.com>
Date:   Fri Apr 2 18:26:10 2021 +0200

    tool_chain: update ali2dep for gcc 10.3.0
    
    Issue #4094

commit 899358c76143591625c62e36ff45e3e8e6d2d6a7
Author: Christian Prochaska <christian.prochaska@genode-labs.com>
Date:   Mon Apr 5 03:09:56 2021 +0200

    stdcxx: update to version 10.3.0
    
    Issue #4094

commit c3e39c74d2b612fdaacbc88943b5ef9965ca4bf9
Author: Christian Prochaska <christian.prochaska@genode-labs.com>
Date:   Sat Apr 3 21:42:46 2021 +0200

    gcov: update to version 10.3.0
    
    Issue #4094

commit c9b6a9eceab8e479dbaee15213a53a4505268fa9
Author: Christian Prochaska <christian.prochaska@genode-labs.com>
Date:   Sun Apr 4 23:42:20 2021 +0200

    sanitizer: update to version 10.3.0
    
    Issue #4094

commit eeb8dbf044364d8e058d8e373a0069b918388a1d
Author: Christian Prochaska <christian.prochaska@genode-labs.com>
Date:   Fri Apr 23 14:30:26 2021 +0200

    Remove mpc and mpfr ports
    
    These ports are not needed anymore with the 21.05 tool chain update.
    
    Issue #4094

commit 34d27a21b37b1fce443f97fe5f21c661b2593dab
Author: Martin Stein <martin.stein@genode-labs.com>
Date:   Wed May 5 15:34:07 2021 +0200

    ports/ada-runtime: update to support gcc 10
    
    Fixes #4128

commit 97b66c2fd4a7a128461808b19939b7baf4baccb0
Author: Martin Stein <martin.stein@genode-labs.com>
Date:   Tue May 11 17:36:41 2021 +0200

    ports/libsparkcrypto: update for GCC 10
    
    The old port version contained '*.ali' files that were build with an older GCC
    which led to problems when compiling packages that use the port with the new
    GCC 10. The '*.ali' files of the new port version were generated with GCC 10.
    
    Fixes #4145

commit f28075a5c2bde2e39ccc1f86f76af730d61e8114
Author: Christian Prochaska <christian.prochaska@genode-labs.com>
Date:   Sun May 23 21:33:55 2021 +0200

    tool chain: update gdb to version 10.2
    
    Issue #4094


Utilities for porting Linux drivers
===================================

Dummy-function generator
------------------------

While porting device drivers from the Linux kernel to Genode, one has to tailor
the environment that replaces the original kernel code. Thereby, tons of
missing function and variable implementations have to be written. Most of them
won't even by called by the driver under normal circumstances, but nonetheless
they are needed to make the linking process work.

The production of these dummy functions in the first place is a tiresome and
annoying work. To free developers from this burden, a new tool entered the
Genode framework under 'tool/dde_linux/create_dummies'. Apart from the creation
of missing kernel functions and variables, it can also be used to easily
summarize all missing symbols during the porting work.

For a more detailed explanation of the new tool, please have a look at the
following article.

:Linux device driver ports - Breaking new ground:

  [http://genodians.org/skalk/2021-04-08-dde-linux-experiments-1]


Device-tree source processing
-----------------------------

Device-tree source files as featured in the source tree of the Linux kernel
contain valuable information about the structure and parameters of SoCs and
boards. The porting and implementing of device drivers for Genode calls for
tooling that is able to extract and convert this information to digestible
forms. The current release introduces the first version of a new tool set at
_tools/dts/_ for this purpose.

[image dts_extract]

The tool aids the understanding of the hardware and allows for the pruning of
device trees down to a manageable complexity. As an illustration, the
spiderweb on the left shows the device-interdependency of the Pine-A64-LTS
board on the left. On the right, the device tree is pruned to cover only
what's needed to use Ethernet. The tool is covered in more detail by the
following dedicated article.

:Pruning device trees:

  [http://genodians.org/nfeske/2021-05-19-pine-dts-pruning]


Cache for downloaded ports
==========================

When working with ports, it is not uncommon that a
port hash is changed due to some minor change like adding a patch.
A subsequent call of 'prepare_port' needs to download the same files
that were downloaded for the preparing previous version of port even if
the downloaded content remains the same. This wastes internet bandwidth
and developer time. The current release introduces a simple cache for
downloaded archives, which mitigates these costs.

_Thanks to Tomasz Gajewski for his continuous contributions to improve our_
_development workflows._


Common hook for custom build rules
==================================

There are cases that call for building custom targets in addition to a regular
library or or program. For example, the executable binary of an application
may be accompanied by generated data files. The creation of such build
artifacts can be expressed by custom make rules. However, a rule is triggered
only if it is a dependency of the build target. This can be achieved by adding
the rule to the 'CUSTOM_TARGET_DEPS' variable. For example,

! CUSTOM_TARGET_DEPS += menu_view_styles.tar
!
! menu_view_styles.tar:
!    $(VERBOSE)cd $(PRG_DIR); tar cf $(PWD)/bin/$@ styles

_Thanks to Tomasz Gajewski for this welcome contribution._

